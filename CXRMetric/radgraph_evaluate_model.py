import json
import numpy as np
import os
import pandas as pd
from scipy import stats
from tqdm import tqdm

from CXRMetric.radgraph_inference import inference

"""Evalutes RadGraph results of reports generated by different models."""


def compute_f1(test, retrieved):
    """Computes F1 between test/retrieved report's entities or relations.

    Args:
      test: Set of test report's entities or relations.
      retrieved: Set of potential retrieved report's entities or relations.

    Returns:
      Entity or relation match F1 score.
    """
    true_positives = len(test.intersection(retrieved))
    false_positives = len(retrieved) - true_positives
    false_negatives = len(test) - true_positives
    precision = true_positives / (true_positives + false_positives) \
            if true_positives + false_positives != 0 else 0
    recall = true_positives / (true_positives + false_negatives) \
            if true_positives + false_negatives != 0 else 0
    f1 = 2 * precision * recall / (precision + recall) \
            if precision + recall != 0 else 0
    return f1

def generate_radgraph(model_path, data_path, out_path):
    """Generates RadGraph predictions."""
    # Create temp directory if it doesn't exist
    os.makedirs('temp', exist_ok=True)
    
    # Set absolute paths
    temp_output = os.path.join(os.path.dirname(out_path), 'temp_dygie_output.json')
    
    # Run inference with correct paths
    data_source = inference.preprocess_reports(data_path)
    data_split = inference.run_inference(model_path, data_source, temp_output)
    
    # Process predictions and save to separate files
    predictions = inference.postprocess_reports(data_source, data_split, temp_output)
    
    # Split predictions into entities and relations
    entities_dict = {}
    relations_dict = {}
    
    for doc_key, pred in predictions.items():
        entities_dict[doc_key] = pred['entities']
        relations_dict[doc_key] = pred['relations']
    
    # Save entities and relations to separate files
    entities_path = os.path.join(os.path.dirname(out_path), 'entities_cache.json')
    relations_path = os.path.join(os.path.dirname(out_path), 'relations_cache.json')
    
    with open(entities_path, 'w') as f:
        json.dump(entities_dict, f)
    
    with open(relations_path, 'w') as f:
        json.dump(relations_dict, f)
    
    return entities_path, relations_path

def parse_entity_relation(path):
    """Parses entities and relations from RadGraph outputs.

    Args:
      path: Path to RadGraph outputs.

    Returns:
      Entities as {(token, label), ...}, and relations as
      {(entity1, entity2, relation), ...}.
    """
    with open(path, "r") as f:
        radgraph_results = json.load(f)

    entities = {dicom_report_id: {(entity["tokens"], entity["label"]) \
                            for _, entity in outputs["entities"].items()} \
                for (dicom_report_id, outputs) in tqdm(radgraph_results.items())}

    relations = dict()
    for dicom_report_id, outputs in tqdm(radgraph_results.items()):
        relations[dicom_report_id] = set()
        for _, entity in outputs["entities"].items():
            relations[dicom_report_id].update(
                    {((entity["tokens"], entity["label"]),
                      (radgraph_results[dicom_report_id]["entities"]\
                               [relation[1]]["tokens"],
                       radgraph_results[dicom_report_id]["entities"]\
                               [relation[1]]["label"]),
                      relation[0],
                     ) for relation in entity["relations"]})

    return entities, relations


def evaluate_radgraph(ground_truth_path, generated_path,
                      entity_output_path, relation_output_path):
    """Evaluates RadGraph entities and relations overlap in F1 scores.

    Note that for a study with multiple images (DICOM IDs), we take the report
    of some image with the highest RadGraph F1 score.

    Args:
      ground_truth_path: Path to ground-truth reports RadGraph outputs.
      generated_path: Path to generated reports RadGraph outputs.
      entity_output_path: Path to write entity F1 scores as
          {study ID: (F1, DICOM ID, (test entity count, generated entity
                                     count))}.
      relation_output_path: Path to write relation F1 scores as
          {study ID: (F1, DICOM ID, (test relation count, generated relation
                                     count))}.
    """
    ground_truth_entities, ground_truth_relations = \
            parse_entity_relation(ground_truth_path)
    generated_entities, generated_relations = \
            parse_entity_relation(generated_path)

    entity_f1s = {}
    relation_f1s = {}
    for dicom_report_id, results in ground_truth_entities.items():
        if not dicom_report_id in generated_entities:  # 0 match
            generated_entities[dicom_report_id] = {}
        f1 = compute_f1(
                results,
                generated_entities[dicom_report_id])
        try:
            dicom_id, report_id = dicom_report_id.split("_")
        except ValueError:
            dicom_id = None
            report_id = dicom_report_id
        if not report_id in entity_f1s:
            entity_f1s[report_id] = \
                    (f1, dicom_id, (len(results),
                                    len(generated_entities[dicom_report_id])))
        elif f1 > entity_f1s[report_id][0]:
            entity_f1s[report_id] = \
                    (f1, dicom_id, (len(results),
                                    len(generated_entities[dicom_report_id])))
    for dicom_report_id, results in ground_truth_relations.items():
        if not dicom_report_id in generated_relations:  # 0 match
            generated_relations[dicom_report_id] = {}
        f1 = compute_f1(
                results,
                generated_relations[dicom_report_id])
        try:
            dicom_id, report_id = dicom_report_id.split("_")
        except ValueError:
            dicom_id = None
            report_id = dicom_report_id
        if not report_id in relation_f1s:
            relation_f1s[report_id] = \
                    (f1, dicom_id, (len(results),
                                    len(generated_relations[dicom_report_id])))
        elif f1 > relation_f1s[report_id][0]:
            relation_f1s[report_id] = \
                    (f1, dicom_id, (len(results),
                                    len(generated_relations[dicom_report_id])))

    with open(entity_output_path, "w") as f:
        json.dump(entity_f1s, f)
    with open(relation_output_path, "w") as f:
        json.dump(relation_f1s, f)

    # Average over all reports (study ID level)
    avg_entity_f1 = sum(
            [f1 for f1, _, _ in entity_f1s.values()]) / len(entity_f1s)
    avg_relation_f1 = sum(
            [f1 for f1, _, _ in relation_f1s.values()]) / len(relation_f1s)
    print(f"Average RadGraph entity F1 = {avg_entity_f1}\n"
          f"Average RadGraph relation F1 = {avg_relation_f1}\n")

    # Compute average entity and relation counts over reports (study ID level)
    gt_entity_count = sum(
            [gt_count for f1, _, (gt_count, _) \
             in entity_f1s.values()]) / len(entity_f1s)
    gt_relation_count = sum(
            [gt_count for f1, _, (gt_count, _) \
             in relation_f1s.values()]) / len(relation_f1s)
    avg_entity_count = sum(
            [generated_count for f1, _, (_, generated_count) \
             in entity_f1s.values()]) / len(entity_f1s)
    avg_relation_count = sum(
            [generated_count for f1, _, (_, generated_count) \
             in relation_f1s.values()]) / len(relation_f1s)
    print(f"Ground truth average RadGraph entity counts = {gt_entity_count}\n"
          f"Ground truth average RadGraph relation counts = {gt_relation_count}\n"
          f"Average RadGraph entity counts = {avg_entity_count}\n"
          f"Average RadGraph relation counts = {avg_relation_count}\n")

    print(f"#Test reports (this is all test cases): {len(entity_f1s)}")


def add_radgraph_results_to_csv(entity_output_path, relation_output_path,
                                csv_path):
    """Adds RadGraph scores as columns to CSV indexed by study_id.

    RadGraph scores are added as "radgraph_entity", "radgraph_relation",
    "radgraph_combined".

    Args:
      entity_output_path: Path to json of entity F1 scores as
          {study ID: (F1, DICOM ID, (test entity count, generated entity
                                     count))}.
      relation_output_path: Path to json of relation F1 scores as
          {study ID: (F1, DICOM ID, (test relation count, generated relation
                                     count))}.
      csv_path: Path to CSV indexed by study_id.
    """
    with open(entity_output_path, "r") as f:
        entity_f1s = json.load(f)
    with open(relation_output_path, "r") as f:
        relation_f1s = json.load(f)
    df = pd.read_csv(csv_path)
    entity_results = []
    relation_results = []
    combined_results = []
    for index, row in df.iterrows():
        study_id = str(row["study_id"])
        entity_f1, _, _ = entity_f1s[study_id]
        relation_f1, _, _ = relation_f1s[study_id]
        entity_results.append(entity_f1)
        relation_results.append(relation_f1)
        combined_results.append((entity_f1 + relation_f1) / 2)
    df["radgraph_entity"] = entity_results
    df["radgraph_relation"] = relation_results
    df["radgraph_combined"] = combined_results
    df.to_csv(csv_path)


def compute_CI(entity_output_path, relation_output_path, bootstrap_k=5000,
               level=0.95):
    """Adds RadGraph scores as columns to CSV indexed by study_id.

    RadGraph scores are added as "radgraph_entity", "radgraph_relation",
    "radgraph_combined".

    Args:
      entity_output_path: Path to json of entity F1 scores as
          {study ID: (F1, DICOM ID, (test entity count, generated entity
                                     count))}.
      relation_output_path: Path to json of relation F1 scores as
          {study ID: (F1, DICOM ID, (test relation count, generated relation
                                     count))}.
      csv_path: Path to CSV indexed by study_id.
    """
    def _compute_CI(output_path, output_type, bootstrap_k, level):
        print("\nComputing confidence intervals (CIs)...")
        with open(output_path, "r") as f:
            f1s = json.load(f)
        print(f"{output_type} result #study_ids: {len(f1s)}")
        results = [f1 for f1, _, _ in f1s.values()]

        results = np.array(results)
        bootstrap = np.random.choice(results, size=bootstrap_k, replace=True)
        mean, ste = np.mean(bootstrap), stats.sem(bootstrap)
        ci  = ste * stats.t.ppf((1 + level) / 2., len(bootstrap) - 1)
        print(f"CI: [{mean - ci:.3f}, {mean:.3f}, {mean + ci:.3f}]")
    _compute_CI(entity_output_path, "Entity", bootstrap_k=bootstrap_k,
                level=level)
    _compute_CI(relation_output_path, "Relation", bootstrap_k=bootstrap_k,
                level=level)

def run_radgraph(gt_path, pred_path, cache_path, model_path, entities_path, relations_path):
    """Runs RadGraph evaluation."""
    # Create cache directory if it doesn't exist
    os.makedirs(cache_path, exist_ok=True)
    
    print("Generating RadGraph predictions for ground truth...")
    gt_entities_path, gt_relations_path = generate_radgraph(model_path, gt_path, os.path.join(cache_path, "gt_radgraph.json"))
    
    print("Generating RadGraph predictions for predictions...")
    pred_entities_path, pred_relations_path = generate_radgraph(model_path, pred_path, os.path.join(cache_path, "pred_radgraph.json"))
    
    # Copy final results to expected locations
    with open(gt_entities_path) as f:
        gt_entities = json.load(f)
    with open(pred_entities_path) as f:
        pred_entities = json.load(f)
        
    with open(gt_relations_path) as f:
        gt_relations = json.load(f)
    with open(pred_relations_path) as f:
        pred_relations = json.load(f)
    
    # Save final results
    with open(entities_path, 'w') as f:
        json.dump({
            'gt': gt_entities,
            'pred': pred_entities
        }, f)
        
    with open(relations_path, 'w') as f:
        json.dump({
            'gt': gt_relations,
            'pred': pred_relations
        }, f)
    
    return entities_path, relations_path
